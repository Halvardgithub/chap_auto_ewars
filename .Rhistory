else{theme(axis.text.x = element_blank())}
return(eval_plot)
}
make_full_box_plot <- function(df, criteria, tau, prior){
#Input: df is a full_eval_df, criteria is either "RMSE" or "LS" while tau is either "CT" or "NCT"
# and prior is the specific prior for the precision
if(prior == "Gamma0,00005"){prior_name <- "Gamma(1, 0.00005)"}
else if(prior == "Gamma0,005"){prior_name <- "Gamma(1, 0.005)"}
else{prior_name <- "PC(1, 0.01)"}
precs <- c("75", "150", "300")
means <- c("flat", "delta", "triangle")
plot_list <- list()
x_text_bool <- FALSE
for(m in 1:length(means)){
if(m == length(means)){x_text_bool <- TRUE} #decides if the x_text shows or not
RW1_str <- paste0(criteria, "_RW1_", means[m], "_") #needs "P_tau"
ARW1_str <- paste0(criteria, "_ARW1_", means[m], "_") #needs "P_tau"
df_exempt <- df[, c(paste0(RW1_str, precs[1], "_", tau), paste0(RW1_str, precs[2], "_", tau), paste0(RW1_str, precs[3], "_", tau), paste0(ARW1_str, precs[1], "_", tau), paste0(ARW1_str, precs[2], "_", tau), paste0(ARW1_str, precs[3], "_", tau))] #the relevant columns of df
#Find the min and max value to enforce the same y-axis for the same mean
ymax <- max(df_exempt)
ymin <- min(df_exempt)
for(p in 1:length(precs)){
plot_list[[(m-1)*3 + p]] <- box_plot_eval(df_exempt[, c(p, p +
length(precs))],means[m], precs[p], ymin, ymax, x_text_bool)
}
}
plot <- ggarrange(plotlist = plot_list, ncol = 3, nrow = 3)
#making the title
title <- paste0(criteria, " for Wakefield data with ")
if(tau == "CT"){title <- paste0(title, "constant tau and ")}
else{title <- paste0(title, "non-constant tau and ")}
title <- paste0(title, prior_name)
plot_w_title <- annotate_figure(plot, top = textGrob(title, gp = (gpar(fontsize = 17))))
ggsave(filename = paste0("C:/Users/Halvard/Documents/GitHub/Master-project/Box-plots2/", criteria, "_", tau, "_", prior, ".pdf"), plot = plot_w_title, width = 8, height = 7, units = "in")
return(plot_w_title)
}
make_full_box_plot(full_eval_df, "RMSE", "CT", "Gamma0,005")
make_full_box_plot(full_eval_df, "LS", "CT", "Gamma0,005")
make_full_box_plot(full_eval_df, "RMSE", "NCT", "Gamma0,005")
make_full_box_plot(full_eval_df, "LS", "NCT", "Gamma0,005")
N <- 30
conf_years <- c(9, 10, 11, 12, 13, 14, 15)
prior_str <- "PC" #other alternatives are Gamma0,005 and Gamma0,00005 and PC
if(prior_str == "Gamma0,00005"){
formula_RW1 <- y ~ f(time, model = "rw1", scale.model = T)  + f(us, model = "iid")
} else if(prior_str == "Gamma0,005"){
formula_RW1 <- y ~ f(time, model = "rw1", scale.model = T, hyper = list(prec = list(prior = "loggamma", param = c(1, 0.005))))  + f(us, model = "iid")
} else{
formula_RW1 <- y ~ f(time, model = "rw1", scale.model = T, hyper = list(prec = list(prior = "pc.prec", param = c(1, 0.01))))  + f(us, model = "iid")
}
ARW1_model <- inla.rgeneric.define(inla.rgeneric.AdaptiveRW1.model2, N = N, conflict_years = conf_years, prior_str = prior_str)
formula_ARW1_W <- y ~ f(time, model = ARW1_model,
extraconstr = list(A = matrix(1, nrow = 1, ncol = N), e = 0)) +
f(us, model = "iid")
mod_eval_W <- function(df, mean = "", V = "", P, tau = "") {
df_y <- df[[1]]
df_eta <- df[[2]]
n <- dim(df_y)[2] - 2
eval_df <- data.frame(matrix(NA, nrow = n, ncol = 4))
colnames(eval_df) <- c("RMSE_RW1", "LS_RW1", "RMSE_ARW1", "LS_ARW1")
for(i in 1:n){#iterate over each simulated realization
test_data <- df_y[, c(i, n + 1, n + 2)] #gets the i-th realization + time
colnames(test_data) <- c("y", "time", "us") #makes the colnames match the formula
res_RW1 <- inla(formula_RW1, family = "gaussian", data = test_data,
control.compute = list(cpo = TRUE),
control.family = list(hyper = list(prec =
list(initial = log(P), fixed = TRUE))))
LS_RW1 <- -mean(log(res_RW1$cpo$cpo))
RMSE_RW1 <- RMSE(df_eta[, i], res_RW1$summary.fitted.values$mean)
res_ARW1 <- inla(formula_ARW1_W, family = "gaussian", data = test_data,
control.compute = list(cpo = TRUE),
control.family = list(hyper = list(prec =
list(initial = log(P), fixed = TRUE))))
LS_ARW1 <- -mean(log(res_ARW1$cpo$cpo))
RMSE_ARW1 <- RMSE(df_eta[, i], res_ARW1$summary.fitted.values$mean)
eval_df[i, ] <- c(RMSE_RW1, LS_RW1, RMSE_ARW1, LS_ARW1)
}
save(eval_df, file=paste0("C:/Users/Halvard/Documents/GitHub/Master-project/Wakefield-data/", prior_str, "/Results3/eval_df_", mean, "_", P, "_", tau))
#save(eval_df, file=paste0("C:/Users/Halvard/Documents/GitHub/Master-project/Harmonius-data/", prior_str, "/eval_df_", mean, "_", P, "_", tau))
return()
}
f_75_CT <- mod_eval_W(data_w_flat_75_CT, "flat", "1/75", 75, "CT")
f_150_CT <- mod_eval_W(data_w_flat_150_CT, "flat", "1/150", 150, "CT")
f_300_CT <- mod_eval_W(data_w_flat_300_CT, "flat", "1/300", 300, "CT")
d_75_CT <- mod_eval_W(data_w_delta_75_CT, "delta", "1/75", 75, "CT")
d_150_CT <- mod_eval_W(data_w_delta_150_CT, "delta", "1/150", 150, "CT")
d_300_CT <- mod_eval_W(data_w_delta_300_CT, "delta", "1/300", 300, "CT")
t_75_CT <- mod_eval_W(data_w_triangle_75_CT, "triangle", "1/75", 75, "CT")
t_150_CT <- mod_eval_W(data_w_triangle_150_CT, "triangle", "1/150", 150, "CT")
t_300_CT <- mod_eval_W(data_w_triangle_300_CT, "triangle", "1/300", 300, "CT")
#Data with non-constant tau
f_75_NCT <- mod_eval_W(data_w_flat_75_NCT, "flat", "1/75", 75, "NCT")
f_150_NCT <- mod_eval_W(data_w_flat_150_NCT, "flat", "1/150", 150, "NCT")
f_300_NCT <- mod_eval_W(data_w_flat_300_NCT, "flat", "1/300", 300, "NCT")
d_75_NCT <- mod_eval_W(data_w_delta_75_NCT, "delta", "1/75", 75, "NCT")
d_150_NCT <- mod_eval_W(data_w_delta_150_NCT, "delta", "1/150", 150, "NCT")
d_300_NCT <- mod_eval_W(data_w_delta_300_NCT, "delta", "1/300", 300, "NCT")
t_75_NCT <- mod_eval_W(data_w_triangle_75_NCT, "triangle", "1/75", 75, "NCT")
t_150_NCT <- mod_eval_W(data_w_triangle_150_NCT, "triangle", "1/150", 150, "NCT")
t_300_NCT <- mod_eval_W(data_w_triangle_300_NCT, "triangle", "1/300", 300, "NCT")
#splicing the eval df's together to one with sensible column names
means <- c("flat", "delta", "triangle")
precs <- c("75", "150", "300")
taus <- c("CT", "NCT")
for(m in 1:length(means)){
for(p in 1:length(precs)){
for(t in 1:length(taus)){
load(paste0("C:/Users/Halvard/Documents/GitHub/Master-project/Wakefield-data/", prior_str, "/Results3/eval_df_", means[m], "_", precs[p], "_", taus[t]))
index_str <- paste0("_", means[m], "_", precs[p], "_", taus[t])
colnames(eval_df) <- c(paste0("RMSE_RW1", index_str), paste0("LS_RW1", index_str), paste0("RMSE_ARW1", index_str), paste0("LS_ARW1", index_str))
if(m == 1 & p == 1 & t == 1){
full_eval_df <- eval_df
}
else{
full_eval_df <- cbind(full_eval_df, eval_df)
}
}
}
}
save(full_eval_df, file=paste0("C:/Users/Halvard/Documents/GitHub/Master-project/Wakefield-data/", prior_str,"/Results3/full_eval_df"))
library(ggpubr) #for plotlist in ggarrange
library(grid)
box_plot_eval <- function(df, mean, P, ymin, ymax, x_text_bool){
colnames(df) <- c("RW1", "ARW1")
# Reshape data to long format
df_long <- df %>%
pivot_longer(cols = everything(), names_to = "Category", values_to = "Value")
# Create the boxplot
eval_plot <- ggplot(df_long, aes(x = Category, y = Value, fill = Category)) +
geom_boxplot() +
ggtitle(paste0("Mu: ", mean, ", V: 1/", P)) + xlab("") + ylab("") +
ylim(ymin, ymax) +
scale_fill_manual(values = c("RW1" = "skyblue", "ARW1" = "orange")) +
theme(legend.position ="none") +
if(x_text_bool){theme()}
else{theme(axis.text.x = element_blank())}
return(eval_plot)
}
make_full_box_plot <- function(df, criteria, tau, prior){
#Input: df is a full_eval_df, criteria is either "RMSE" or "LS" while tau is either "CT" or "NCT"
# and prior is the specific prior for the precision
if(prior == "Gamma0,00005"){prior_name <- "Gamma(1, 0.00005)"}
else if(prior == "Gamma0,005"){prior_name <- "Gamma(1, 0.005)"}
else{prior_name <- "PC(1, 0.01)"}
precs <- c("75", "150", "300")
means <- c("flat", "delta", "triangle")
plot_list <- list()
x_text_bool <- FALSE
for(m in 1:length(means)){
if(m == length(means)){x_text_bool <- TRUE} #decides if the x_text shows or not
RW1_str <- paste0(criteria, "_RW1_", means[m], "_") #needs "P_tau"
ARW1_str <- paste0(criteria, "_ARW1_", means[m], "_") #needs "P_tau"
df_exempt <- df[, c(paste0(RW1_str, precs[1], "_", tau), paste0(RW1_str, precs[2], "_", tau), paste0(RW1_str, precs[3], "_", tau), paste0(ARW1_str, precs[1], "_", tau), paste0(ARW1_str, precs[2], "_", tau), paste0(ARW1_str, precs[3], "_", tau))] #the relevant columns of df
#Find the min and max value to enforce the same y-axis for the same mean
ymax <- max(df_exempt)
ymin <- min(df_exempt)
for(p in 1:length(precs)){
plot_list[[(m-1)*3 + p]] <- box_plot_eval(df_exempt[, c(p, p +
length(precs))],means[m], precs[p], ymin, ymax, x_text_bool)
}
}
plot <- ggarrange(plotlist = plot_list, ncol = 3, nrow = 3)
#making the title
title <- paste0(criteria, " for Wakefield data with ")
if(tau == "CT"){title <- paste0(title, "constant tau and ")}
else{title <- paste0(title, "non-constant tau and ")}
title <- paste0(title, prior_name)
plot_w_title <- annotate_figure(plot, top = textGrob(title, gp = (gpar(fontsize = 17))))
ggsave(filename = paste0("C:/Users/Halvard/Documents/GitHub/Master-project/Box-plots2/", criteria, "_", tau, "_", prior, ".pdf"), plot = plot_w_title, width = 8, height = 7, units = "in")
return(plot_w_title)
}
make_full_box_plot(full_eval_df, "RMSE", "CT", "PC")
make_full_box_plot(full_eval_df, "LS", "CT", "PC")
make_full_box_plot(full_eval_df, "RMSE", "NCT", "PC")
make_full_box_plot(full_eval_df, "LS", "NCT", "PC")
library(INLA)
library(dlnm)
library(dplyr)
#for graphs
library(sf)
library(spdep)
model_fn <- "model"
hist_fn <- "example_data_Viet/historic_data.csv"
future_fn <- "example_data_Viet/future_data.csv"
preds_fn <- "example_data_Viet/predictions.csv"
graph_fn <- "example_data_Viet/vietnam.json"
geojson <- st_read(graph_fn)
setwd("C:/Users/Halvard/Documents/GitHub/chap_auto_ewars")
geojson <- st_read(graph_fn)
View(geojson)
df <- read.csv(future_fn)
df_locs <- unique(df$location)
df_locs
geojson$VARNAME_1
geojson <- st_make_valid(geojson)
geojson$VARNAME_1
nb <- poly2nb(geojson, queen = TRUE) #adjacent polygons are neighbors
nb
View(nb)
nb[[24]]
nb[[36]]
geojson_reduced <- geojson[geojson$VARNAME_1 %in% df_locs]
geojson_reduced <- geojson[geojson$VARNAME_1 %in% df_locs, ]
View(geojson_reduced)
nb_red <- poly2nb(geojson_reduced, queen = TRUE) #adjacent polygons are neighbors
View(nb_red)
image(nb_red)
adjacency_red <- nb2mat(nb_red, style = "B", zero.policy = TRUE)
image(adjacency_red)
View(adjacency_red)
row.names(adjacency_red) <- NULL
View(adjacency_red)
image(adjacency_red)
df <- read.csv(future_fn)
df$Cases <- rep(NA, nrow(df))
df$disease_cases <- rep(NA, nrow(df)) #so we can rowbind it with historic
historic_df = read.csv(hist_fn)
df <- rbind(historic_df, df)
#adding a counting variable for the months like 1, ..., 12, 13, ...
#could also do years*12 + months, but fails for weeks
df <-group_by(df, location) |>
mutate(month_num = row_number())
basis_meantemperature <- crossbasis(df$meantemperature, lag=3,
argvar = list(fun = "ns", knots = equalknots(df$meantemperature, 2)),
arglag = list(fun = "ns", knots = 3/2), group = df$ID_spat)
colnames(basis_meantemperature) = paste0("basis_meantemperature.", colnames(basis_meantemperature))
basis_rainsum <- crossbasis(df$rainsum, lag=3,
argvar = list(fun = "ns", knots = equalknots(df$rainsum, 2)),
arglag = list(fun = "ns", knots = 3/2), group = df$ID_spat)
colnames(basis_rainsum) = paste0("basis_rainsum.", colnames(basis_rainsum))
df$ID_spat <- as.factor(df$ID_spat)
df$ID_spat_num <- as.numeric(as.factor(df$ID_spat))
df <- cbind(df, basis_meantemperature, basis_rainsum)
lagged_formula <- Cases ~ 1 + f(ID_spat, model='iid') + f(month_num, model = "rw1", scale.model = T,
replicate = ID_spat_num) +
f(month, model='rw1', cyclic=T, scale.model=T) + basis_meantemperature + basis_rainsum
if(graph_fn != ""){
#df$ID_spat_num2 <- df$ID_spat_num
geojson <- st_read(graph_fn)
geojson <- st_make_valid(geojson)
df_locs <- unique(df$location)
geojson_red <- geojson[geojson$VARNAME_1 %in% df_locs, ]
nb <- poly2nb(geojson_red, queen = TRUE) #adjacent polygons are neighbors
adjacency <- nb2mat(nb, style = "B", zero.policy = TRUE)
# lagged_formula <- Cases ~ 1 + f(ID_spat_num, model = "bym2", graph = adjacency) +
#   f(month_num, model = "rw1", scale.model = T,
#   replicate = ID_spat_num, hyper=list(prec = list(prior = "pc.prec", param = c(1, 0.01)))) +
#   f(month, model='rw1', cyclic=T, scale.model=T, hyper=list(prec = list(prior = "pc.prec",
#   param = c(1, 0.01)))) + basis_meantemperature + basis_rainsum
lagged_formula <- Cases ~ 1 + f(ID_spat_num, model = "bym2", graph = adjacency, replicate = ID_year) +
f(month_num, model = "rw1", scale.model = T,
replicate = ID_spat_num) +
f(month, model='rw1', cyclic=T, scale.model=T) + basis_meantemperature + basis_rainsum
}
model <- inla(formula = lagged_formula, data = df, family = "nbinomial", offset = log(E),
control.inla = list(strategy = 'adaptive'),
control.compute = list(config = TRUE, return.marginals = FALSE),
control.fixed = list(correlation.matrix = TRUE, prec.intercept = 0.1, prec = 1),
control.predictor = list(link = 1, compute = TRUE),
verbose = F, safe=FALSE)
formula
lagged_formula
View(df)
df <- read.csv(future_fn)
df$Cases <- rep(NA, nrow(df))
df$disease_cases <- rep(NA, nrow(df)) #so we can rowbind it with historic
historic_df = read.csv(hist_fn)
df <- rbind(historic_df, df)
df <- mutate(df, ID_year = ID_year - min(df$ID_year) + 1)
#adding a counting variable for the months like 1, ..., 12, 13, ...
#could also do years*12 + months, but fails for weeks
df <-group_by(df, location) |>
mutate(month_num = row_number())
basis_meantemperature <- crossbasis(df$meantemperature, lag=3,
argvar = list(fun = "ns", knots = equalknots(df$meantemperature, 2)),
arglag = list(fun = "ns", knots = 3/2), group = df$ID_spat)
colnames(basis_meantemperature) = paste0("basis_meantemperature.", colnames(basis_meantemperature))
basis_rainsum <- crossbasis(df$rainsum, lag=3,
argvar = list(fun = "ns", knots = equalknots(df$rainsum, 2)),
arglag = list(fun = "ns", knots = 3/2), group = df$ID_spat)
colnames(basis_rainsum) = paste0("basis_rainsum.", colnames(basis_rainsum))
df$ID_spat <- as.factor(df$ID_spat)
df$ID_spat_num <- as.numeric(as.factor(df$ID_spat))
df <- cbind(df, basis_meantemperature, basis_rainsum)
lagged_formula <- Cases ~ 1 + f(ID_spat, model='iid') + f(month_num, model = "rw1", scale.model = T,
replicate = ID_spat_num) +
f(month, model='rw1', cyclic=T, scale.model=T) + basis_meantemperature + basis_rainsum
if(graph_fn != ""){
#df$ID_spat_num2 <- df$ID_spat_num
geojson <- st_read(graph_fn)
geojson <- st_make_valid(geojson)
df_locs <- unique(df$location)
geojson_red <- geojson[geojson$VARNAME_1 %in% df_locs, ]
nb <- poly2nb(geojson_red, queen = TRUE) #adjacent polygons are neighbors
adjacency <- nb2mat(nb, style = "B", zero.policy = TRUE)
# lagged_formula <- Cases ~ 1 + f(ID_spat_num, model = "bym2", graph = adjacency) +
#   f(month_num, model = "rw1", scale.model = T,
#   replicate = ID_spat_num, hyper=list(prec = list(prior = "pc.prec", param = c(1, 0.01)))) +
#   f(month, model='rw1', cyclic=T, scale.model=T, hyper=list(prec = list(prior = "pc.prec",
#   param = c(1, 0.01)))) + basis_meantemperature + basis_rainsum
lagged_formula <- Cases ~ 1 + f(ID_spat_num, model = "bym2", graph = adjacency, replicate = ID_year) +
f(month_num, model = "rw1", scale.model = T, replicate = ID_spat_num) +
f(month, model='rw1', cyclic=T, scale.model=T) + basis_meantemperature + basis_rainsum
}
model <- inla(formula = lagged_formula, data = df, family = "nbinomial", offset = log(E),
control.inla = list(strategy = 'adaptive'),
control.compute = list(config = TRUE, return.marginals = FALSE),
control.fixed = list(correlation.matrix = TRUE, prec.intercept = 0.1, prec = 1),
control.predictor = list(link = 1, compute = TRUE),
verbose = F, safe=FALSE)
summary(model)
model2 <- inla(formula = lagged_formula, data = df, family = "poisson", offset = log(E),
control.inla = list(strategy = 'adaptive'),
control.compute = list(config = TRUE, return.marginals = FALSE),
control.fixed = list(correlation.matrix = TRUE, prec.intercept = 0.1, prec = 1),
control.predictor = list(link = 1, compute = TRUE),
verbose = F, safe=FALSE)
summary(model2)
csi <- model$marginals.random$ID #[1:Nareas]
zeta <- lapply(csi,function(x) inla.emarginal(exp,x))
zeta
model$marginals.random
model$marginals.lincomb.derived
View(model)
model$summary.random
model$summary.spde2.blc
View(model)
plot(st_geometry(geojson),
xlim = c(-20, 60), ylim = c(-40, 35),
col = "steelblue", lwd = 0.5)
plot(st_geometry(geojson),
xlim = c(40, 60), ylim = c(-10, 15),
col = "steelblue", lwd = 0.5)
plot(st_geometry(geojson),
xlim = c(-20, 60), ylim = c(-40, 35),
col = "steelblue", lwd = 0.5)
plot(st_geometry(geojson),
xlim = c(0, 60), ylim = c(-40, 35),
col = "steelblue", lwd = 0.5)
plot(st_geometry(geojson),
xlim = c(30, 60), ylim = c(-40, 35),
col = "steelblue", lwd = 0.5)
plot(st_geometry(geojson),
xlim = c(-60, 60), ylim = c(-40, 35),
col = "steelblue", lwd = 0.5)
plot(st_geometry(geojson),
xlim = c(-60, 60), ylim = c(-20, 35),
col = "steelblue", lwd = 0.5)
plot(st_geometry(geojson),
xlim = c(-60, 60), ylim = c(-0, 35),
col = "steelblue", lwd = 0.5)
plot(st_geometry(geojson),
xlim = c(-60, 60), ylim = c(-50, 35),
col = "steelblue", lwd = 0.5)
plot(st_geometry(geojson),
xlim = c(-60, 60), ylim = c(-50, 0),
col = "steelblue", lwd = 0.5)
par(mar = c(0, 0, 0, 0))
plot(st_geometry(geojson),
xlim = c(-60, 60), ylim = c(-50, 35),
col = "steelblue", lwd = 0.5)
plot(st_geometry(geojson),
xlim = c(-60, 60), ylim = c(-50, 35),
col = "steelblue", lwd = 0.5, asp = 1)
plot(st_geometry(geojson),
col = "steelblue", lwd = 0.5, asp = 1)
plot(st_geometry(geojson_red),
col = "steelblue", lwd = 0.5, asp = 1)
df_loc1 <- df[location == "BinhDihn"]
df_loc1 <- df[location = "BinhDihn"]
df_loc1 <- df[df$location = "BinhDihn"]
df_loc1 <- df[df$location == "BinhDihn"]
df_loc1 <- df[df$location == "BinhDihn", ]
library(ggplot2)
ggplot(df_loc1, aes(x = date)) +
geom_line(aes(y = disease_cases, color = "Disease Cases"), size = 1) +
geom_line(aes(y = rainfall, color = "Rainfall"), size = 1) +
scale_color_manual(values = c("Disease Cases" = "red", "Rainfall" = "blue")) +
labs(title = "Disease Cases and Rainfall Over Time",
x = "Date", y = "Count / Rainfall") +
theme_minimal()
ggplot(df_loc1, aes(x = time_period)) +
geom_line(aes(y = disease_cases, color = "Disease Cases"), size = 1) +
geom_line(aes(y = rainfall, color = "Rainfall"), size = 1) +
scale_color_manual(values = c("Disease Cases" = "red", "Rainfall" = "blue")) +
labs(title = "Disease Cases and Rainfall Over Time",
x = "Date", y = "Count / Rainfall") +
theme_minimal()
ggplot(df_loc1, aes(x = time_period)) +
geom_line(aes(y = disease_cases, color = "Disease Cases"), size = 1) +
geom_line(aes(y = rainfall, color = "Rainfall"), size = 1) +
scale_color_manual(values = c("red", "blue"),
labels = c("Disease Cases", "Rainfall")) +
labs(title = "Disease Cases and Rainfall Over Time",
x = "Date", y = "Count / Rainfall",
color = "Legend") +
theme_minimal()
library(tidyr)
library(ggplot2)
# Convert to long format
df_long <- df_loc1 %>%
pivot_longer(cols = c(disease_cases, rainfall),
names_to = "variable", values_to = "value")
# View the transformed data (optional)
head(df_long)
ggplot(df_long, aes(x = time_period, y = value, color = variable)) +
geom_line(size = 1) +
scale_color_manual(values = c("disease_cases" = "red", "rainfall" = "blue"),
labels = c("Disease Cases", "Rainfall")) +
labs(title = "Disease Cases and Rainfall Over Time",
x = "Date", y = "Count / Rainfall") +
theme_minimal()
ggplot(df_long, aes(x = time_period, y = value, color = variable)) +
geom_line(size = 1) +
labs(title = "Disease Cases and Rainfall Over Time",
x = "Date", y = "Count / Rainfall") +
theme_minimal()
df_loc1
df_loc1
df_loc1 <- df[df$location == "BinhDihn", ]
df_loc1
df$location == "BinhDihn"
unique(df$location)
un <- unique(df$location)
df_loc1 <- df[df$location == un[1], ]
df_loc1
ggplot(df_loc1, aes(x = time_period)) +
geom_line(aes(y = disease_cases, color = "Disease Cases"), size = 1) +
geom_line(aes(y = rainfall, color = "Rainfall"), size = 1) +
scale_color_manual(values = c("red", "blue"),
labels = c("Disease Cases", "Rainfall")) +
labs(title = "Disease Cases and Rainfall Over Time",
x = "Date", y = "Count / Rainfall",
color = "Legend") +
theme_minimal()
ggplot(df_loc1, aes(x = time_period)) +
geom_line(aes(y = disease_cases), size = 1) +
geom_line(aes(y = rainfall), size = 1) +
labs(title = "Disease Cases and Rainfall Over Time",
x = "Date", y = "Count / Rainfall",
color = "Legend") +
theme_minimal()
df_loc1 <- df[df$location == un[1], ]
View(df_loc1)
ggplot(df_loc1, aes(x = time_period)) +
geom_line(aes(y = disease_cases)) +
geom_line(aes(y = rainfall)) +
labs(title = "Disease Cases and Rainfall Over Time",
x = "Date", y = "Count / Rainfall",
color = "Legend") +
theme_minimal()
df_loc1 <- df[df$location == un[1], ][c("rainfall", "disease_cases")]
df_loc1$t <- 1:nrow(df_loc1)  # Create a time index from 1 to n
df_long <- df_loc1 %>% pivot_longer(cols = -t, names_to = "variable", values_to = "value")
ggplot(df_long, aes(x = t, y = value, color = variable)) +
geom_line() +
labs(title = "title",
x = "x", y = "y") +
theme(legend.title = element_blank())
ccf(df_loc1$rainfall, df_loc1$disease_cases,
main = "Cross-Correlation between Rainfall and Disease Cases")
library(zoo)
df_loc1$rainfall <- na.locf(df_loc1$rainfall)
df_loc1$disease_cases <- na.locf(df_loc1$disease_cases)
ccf(df_loc1$rainfall, df_loc1$disease_cases,
main = "Cross-Correlation between Rainfall and Disease Cases")
df_loc1 <- df[df$location == un[2], ][c("rainfall", "disease_cases")]
library(ggplot2)
df_loc1$t <- 1:nrow(df_loc1)  # Create a time index from 1 to n
df_long <- df_loc1 %>% pivot_longer(cols = -t, names_to = "variable", values_to = "value")
ggplot(df_long, aes(x = t, y = value, color = variable)) +
geom_line() +
labs(title = "title",
x = "x", y = "y") +
theme(legend.title = element_blank())
df_loc1$rainfall <- na.locf(df_loc1$rainfall)
df_loc1$disease_cases <- na.locf(df_loc1$disease_cases)
ccf(df_loc1$rainfall, df_loc1$disease_cases,
main = "Cross-Correlation between Rainfall and Disease Cases")
df_loc1 <- df[df$location == un[3], ][c("rainfall", "disease_cases")]
library(ggplot2)
df_loc1$t <- 1:nrow(df_loc1)  # Create a time index from 1 to n
df_long <- df_loc1 %>% pivot_longer(cols = -t, names_to = "variable", values_to = "value")
ggplot(df_long, aes(x = t, y = value, color = variable)) +
geom_line() +
labs(title = "title",
x = "x", y = "y") +
theme(legend.title = element_blank())
df_loc1$rainfall <- na.locf(df_loc1$rainfall)
df_loc1$disease_cases <- na.locf(df_loc1$disease_cases)
ccf(df_loc1$rainfall, df_loc1$disease_cases,
main = "Cross-Correlation between Rainfall and Disease Cases")
acf(df_loc1$disease_cases)
plot(model$summary.random$month_num)
plot(model$summary.random$month_num$mean)
model$summary.random$month_num
plot(model$summary.random$month_num$mean[1:200])
plot(model$summary.random$month_num$mean[205:410])
lagged_formula <- Cases ~ 1 + f(ID_spat_num, model = "bym2", graph = adjacency, replicate = ID_year) +
f(month_num, model = "rw1", scale.model = T, replicate = ID_spat_num) +
f(month, model='rw2', cyclic=T, scale.model=T) + basis_meantemperature + basis_rainsum
model <- inla(formula = lagged_formula, data = df, family = "poisson", offset = log(E),
control.inla = list(strategy = 'adaptive'),
control.compute = list(config = TRUE, return.marginals = FALSE),
control.fixed = list(correlation.matrix = TRUE, prec.intercept = 0.1, prec = 1),
control.predictor = list(link = 1, compute = TRUE),
verbose = F, safe=FALSE)
plot(model$summary.random$month_num$mean[205:410])
plot(model$summary.random$month_num$mean[1:200])
plot(model$summary.random$month_num$mean[400:600])
plot(model$summary.random$month_num$mean[600:800])
plot(model$summary.random$month_num$mean[800:1000])
